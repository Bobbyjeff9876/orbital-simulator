<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Orbital Mechanics Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #f1f5f9;
            overflow: hidden;
        }
        #scene-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 400px;
            background-color: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(8px);
            border-top: 1px solid #334155;
            z-index: 20;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out;
            transform: translateY(0);
        }
        #ui-container:not(.open) {
            transform: translateY(400px);
        }
        #ui-scroll-container {
            flex: 1;
            display: flex;
            flex-direction: row;
            overflow-x: auto;
            overflow-y: hidden;
        }
        .ui-section {
            padding: 1.5rem;
            border-right: 1px solid #334155;
            width: 360px;
            flex-shrink: 0;
            height: 100%;
            overflow-y: auto;
        }
        .ui-section:last-child {
            border-right: none;
        }
        #ui-footer {
            padding: 1rem 1.5rem;
            border-top: 1px solid #334155;
            flex-shrink: 0;
        }
        #toggle-button {
            position: absolute;
            top: -45px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 25;
            background-color: #1e293b;
            color: #f1f5f9;
            border: 1px solid #334155;
            border-bottom: none;
            padding: 8px 20px;
            border-top-right-radius: 8px;
            border-top-left-radius: 8px;
            cursor: pointer;
        }
        #ui-container:not(.open) #toggle-icon {
            transform: rotate(0deg);
        }
        #toggle-icon {
            transform: rotate(180deg);
            transition: transform 0.3s ease-in-out;
        }
        
        .input-group {
            margin-bottom: 1rem;
        }
        .input-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: #94a3b8;
        }
        .input-group input[type="number"] {
            width: 100%;
            background-color: #1e293b;
            border: 1px solid #334155;
            color: #f1f5f9;
            border-radius: 0.375rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
        }
        .input-group input[type="range"] {
             width: 100%;
            height: 0.5rem;
            background-color: #334155;
            border-radius: 0.5rem;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        .input-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1rem;
            height: 1rem;
            background-color: #3b82f6;
            border-radius: 9999px;
            cursor: pointer;
        }
        .input-group input[type="range"]::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            background-color: #3b82f6;
            border-radius: 9999px;
            cursor: pointer;
        }
        .plot-button {
            width: 100%;
            background-color: #3b82f6;
            color: white;
            font-weight: 700;
            padding: 0.75rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .plot-button:hover {
            background-color: #2563eb;
        }
        .secondary-button {
            width: 100%;
            background-color: #334155;
            color: #cbd5e1;
            font-weight: 500;
            padding: 0.5rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            cursor: pointer;
            text-align: center;
        }
        .secondary-button:hover {
            background-color: #475569;
        }
        .maneuver-button {
            width: 100%;
            background-color: #db2777;
            color: white;
            font-weight: 700;
            padding: 0.75rem;
            border-radius: 0.375rem;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .maneuver-button:hover {
            background-color: #be185d;
        }
        .data-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }
        .data-item {
            background-color: #1e293b;
            padding: 0.75rem;
            border-radius: 0.375rem;
        }
        .data-item-title {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-bottom: 0.25rem;
            text-transform: uppercase;
        }
        .data-item-value {
            font-size: 1.125rem;
            font-weight: 700;
            color: #f1f5f9;
        }
        .data-item-value span.unit {
            font-size: 0.875rem;
            font-weight: 400;
            color: #94a3b8;
            margin-left: 0.25rem;
        }
        #ground-track-canvas {
            width: 100%;
            height: 151px;
            background-color: #1e293b;
            border-radius: 0.375rem;
            border: 1px solid #334155;
            margin-bottom: 1rem;
        }
        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #1e293b;
            padding: 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid #334155;
        }
        .toggle-switch label {
            font-size: 0.875rem;
            font-weight: 500;
            color: #cbd5e1;
            margin: 0;
        }
        .toggle-switch input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 40px;
            height: 20px;
            background-color: #334155;
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .toggle-switch input[type="checkbox"]::before {
            content: "";
            width: 16px;
            height: 16px;
            background-color: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: transform 0.2s;
        }
        .toggle-switch input[type="checkbox"]:checked {
            background-color: #3b82f6;
        }
        .toggle-switch input[type="checkbox"]:checked::before {
            transform: translateX(20px);
        }
    </style>
</head>
<body class="antialiased">

    <div id="scene-container"></div>

    <div id="ui-container" class="open">
        <button id="toggle-button" title="Toggle Panel">
            <svg id="toggle-icon" class="w-4 h-4 fill-current" viewBox="0 0 20 20"><path d="M10 12.586l-4.293-4.293-1.414 1.414L10 15.414l5.707-5.707-1.414-1.414L10 12.586z"/></svg>
        </button>
        
        <div id="ui-scroll-container">
            <div class="ui-section">
                <h2 class="text-xl font-bold mb-4">Orbital Parameters</h2>
                
                <div class="input-group">
                    <label for="semi-major-axis">Semi-Major Axis (a) <span class="text-slate-500">km</span></label>
                    <input type="number" id="semi-major-axis" value="6778">
                </div>
                
                <div class="input-group">
                    <label for="eccentricity">Eccentricity (e)</label>
                    <input type="number" id="eccentricity" step="0.01" value="0.0007">
                </div>
                
                <div class="input-group">
                    <label for="inclination">Inclination (i) <span class="text-slate-500">°</span></label>
                    <input type="number" id="inclination" value="51.6">
                </div>
                
                <div class="input-group">
                    <label for="raan">RAAN (Ω) <span class="text-slate-500">°</span></label>
                    <input type="number" id="raan" value="0">
                </div>
                
                <div class="input-group">
                    <label for="arg-periapsis">Argument of Periapsis (ω) <span class="text-slate-500">°</span></label>
                    <input type="number" id="arg-periapsis" value="0">
                </div>

                <button id="plot-button" class="plot-button">Plot Orbit</button>
            </div>
            
            <div class="ui-section">
                <h2 class="text-xl font-bold mb-4">Perturbations</h2>
                <div class="toggle-switch">
                    <label for="j2-toggle">J2 Effect (Earth's Bulge)</label>
                    <input type="checkbox" id="j2-toggle">
                </div>
            </div>
            
            <div class="ui-section">
                <h2 class="text-xl font-bold mb-4">Maneuver Planner</h2>
                <div class="input-group">
                    <label for="target-altitude">Target Altitude (circular) <span class="text-slate-500">km</span></label>
                    <input type="number" id="target-altitude" value="35786">
                </div>
                <button id="calculate-transfer-button" class="maneuver-button">Calculate Hohmann Transfer</button>
                
                <div class="data-grid mt-4">
                    <div class="data-item">
                        <div class="data-item-title">Delta-V 1</div>
                        <div class="data-item-value" id="data-dv1">- <span class="unit">m/s</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Delta-V 2</div>
                        <div class="data-item-value" id="data-dv2">- <span class="unit">m/s</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Total Delta-V</div>
                        <div class="data-item-value" id="data-dv-total">- <span class="unit">m/s</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Transfer Time</div>
                        <div class="data-item-value" id="data-transfer-time">- <span class="unit">hr</span></div>
                    </div>
                </div>
                <p id="maneuver-error" class="text-red-400 text-sm mt-2"></p>
            </div>

            <div class="ui-section">
                <h2 class="text-xl font-bold mb-4">Real-time Data</h2>
                <div class="data-grid">
                    <div class="data-item">
                        <div class="data-item-title">Apoapsis</div>
                        <div class="data-item-value" id="data-apoapsis">- <span class="unit">km</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Periapsis</div>
                        <div class="data-item-value" id="data-periapsis">- <span class="unit">km</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Altitude</div>
                        <div class="data-item-value" id="data-altitude">- <span class="unit">km</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Period</div>
                        <div class="data-item-value" id="data-period">- <span class="unit">min</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Current RAAN (Ω)</div>
                        <div class="data-item-value" id="data-raan">- <span class="unit">°</span></div>
                    </div>
                    <div class="data-item">
                        <div class="data-item-title">Current ω</div>
                        <div class="data-item-value" id="data-w">- <span class="unit">°</span></div>
                    </div>
                    <div class="data-item col-span-2">
                        <div class="data-item-title">Eclipse Status</div>
                        <div class="data-item-value" id="data-eclipse">-</div>
                    </div>
                </div>

                <div class="input-group mt-6">
                    <label for="time-scale" class="flex justify-between items-center text-sm font-medium text-slate-400 mb-2">
                        <span>Time Scale</span>
                        <span id="time-scale-value" class="text-slate-100 font-bold">1x</span>
                    </label>
                    <input type="range" id="time-scale" min="0" max="4" step="0.1" value="0">
                </div>
            </div>
            
            <div class="ui-section">
                <h2 class="text-xl font-bold mb-4">Ground Track</h2>
                <canvas id="ground-track-canvas" width="302" height="151"></canvas>
                <button id="clear-track-button" class="secondary-button">Clear Track</button>
            </div>
        </div>
        
        <div id="ui-footer" class="text-xs text-slate-500">
            <p>Drag to rotate. Scroll to zoom. Right-click to pan.</p>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const EARTH_RADIUS_KM = 6378.137;
        const G_KM = 398600.4418;
        const J2 = 1.08262668e-3;
        const SCENE_SCALE = 1 / 1000;
        const EARTH_ROTATION_RAD_PER_SEC = 7.2921159e-5;
        
        const MAP_URL = 'https://upload.wikimedia.org/wikipedia/commons/8/83/Equirectangular_projection_SW.jpg';
        const EARTH_DAY_URL = 'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg';
        const EARTH_NIGHT_URL = 'https://threejs.org/examples/textures/planets/earth_nightmap.jpg';
        const EARTH_CLOUDS_URL = 'https://threejs.org/examples/textures/planets/earth_clouds.png';

        let scene, camera, renderer, controls, earth, satellite;
        let sunLight, earthGroup, cloudMesh; 
        let currentOrbitGroup, transferOrbitGroup, finalOrbitGroup;
        let currentOrbitParams = null; 
        const clock = new THREE.Clock(); 
        let timeScale = 1.0; 
        let simulationTime = 0; 
        const textureLoader = new THREE.TextureLoader();
        
        let sceneContainer, plotButton, toggleButton, uiContainer;
        let dataApoapsis, dataPeriapsis, dataAltitude, dataPeriod, dataEclipse;
        let timeScaleSlider, timeScaleValue; 
        
        let groundTrackCanvas, groundTrackCtx, clearTrackButton;
        const mapImage = new Image();
        let lastGroundTrackPoint = null;
        
        let calculateTransferButton, targetAltitudeInput, maneuverErrorText;
        let dataDv1, dataDv2, dataDvTotal, dataTransferTime;
        
        let j2Toggle, dataRaan, dataW;

        function init() {
            sceneContainer = document.getElementById('scene-container');
            plotButton = document.getElementById('plot-button');
            toggleButton = document.getElementById('toggle-button');
            uiContainer = document.getElementById('ui-container');
            
            dataApoapsis = document.getElementById('data-apoapsis');
            dataPeriapsis = document.getElementById('data-periapsis');
            dataAltitude = document.getElementById('data-altitude'); 
            dataPeriod = document.getElementById('data-period');
            dataEclipse = document.getElementById('data-eclipse'); 
            dataRaan = document.getElementById('data-raan');
            dataW = document.getElementById('data-w');
            
            timeScaleSlider = document.getElementById('time-scale');
            timeScaleValue = document.getElementById('time-scale-value');
            
            groundTrackCanvas = document.getElementById('ground-track-canvas');
            clearTrackButton = document.getElementById('clear-track-button');
            if (groundTrackCanvas) {
                groundTrackCtx = groundTrackCanvas.getContext('2d');
            } else {
                console.error("Failed to find #ground-track-canvas");
            }
            
            calculateTransferButton = document.getElementById('calculate-transfer-button');
            targetAltitudeInput = document.getElementById('target-altitude');
            maneuverErrorText = document.getElementById('maneuver-error');
            dataDv1 = document.getElementById('data-dv1');
            dataDv2 = document.getElementById('data-dv2');
            dataDvTotal = document.getElementById('data-dv-total');
            dataTransferTime = document.getElementById('data-transfer-time');
            
            j2Toggle = document.getElementById('j2-toggle');
            
            mapImage.crossOrigin = "Anonymous"; 
            mapImage.onload = () => {
                drawGroundTrackMap();
            };
            mapImage.onerror = () => {
                console.error("Failed to load map image.");
                if (groundTrackCtx) {
                    groundTrackCtx.fillStyle = '#f1f5f9';
                    groundTrackCtx.fillText("Failed to load map.", 10, 20);
                }
            };
            mapImage.src = MAP_URL;

            if(dataAltitude) {
                dataAltitude.innerHTML = `- <span class="unit">km</span>`; 
            } else {
                console.error("Failed to find #data-altitude at init start.");
            }

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, getAspectRatio(), 0.1, 1000);
            camera.position.set(0, 40, 60); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(getWidth(), getHeight());
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 0); 
            sceneContainer.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            
            sunLight = new THREE.DirectionalLight(0xffffff, 2.5);
            sunLight.position.set(1000, 0, 0);
            scene.add(sunLight);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.minDistance = EARTH_RADIUS_KM * SCENE_SCALE + 2;
            controls.maxDistance = 500;
            
            earthGroup = new THREE.Group();
            
            textureLoader.setCrossOrigin('Anonymous');
            
            const earthDayTexture = textureLoader.load(EARTH_DAY_URL);
            const earthNightTexture = textureLoader.load(EARTH_NIGHT_URL);
            const cloudTexture = textureLoader.load(EARTH_CLOUDS_URL);

            const earthGeometry = new THREE.SphereGeometry(EARTH_RADIUS_KM * SCENE_SCALE, 64, 64);
            const earthMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                map: earthDayTexture,
                emissive: 0xffffff,
                emissiveMap: earthNightTexture,
                emissiveIntensity: 1.0,
                roughness: 0.8 
            });
            earth = new THREE.Mesh(earthGeometry, earthMaterial);
            earthGroup.add(earth);

            const cloudGeometry = new THREE.SphereGeometry(EARTH_RADIUS_KM * SCENE_SCALE + 0.1, 64, 64);
            const cloudMaterial = new THREE.MeshBasicMaterial({
                map: cloudTexture,
                transparent: true,
                opacity: 0.4
            });
            cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
            earthGroup.add(cloudMesh);
            
            scene.add(earthGroup);

            const ringGeometry = new THREE.RingGeometry(EARTH_RADIUS_KM * SCENE_SCALE + 0.2, EARTH_RADIUS_KM * SCENE_SCALE + 0.3, 128);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, opacity: 0.5, transparent: true });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            scene.add(ring); 

            const axesHelper = new THREE.AxesHelper(EARTH_RADIUS_KM * SCENE_SCALE + 5); 
            scene.add(axesHelper);

            const satGeometry = new THREE.ConeGeometry(0.3, 0.6, 16); 
            const satMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffff00, 
                emissive: 0xccaa00 
            });
            satellite = new THREE.Mesh(satGeometry, satMaterial);
            satellite.visible = false; 
            scene.add(satellite);

            window.addEventListener('resize', onWindowResize);
            
            if (plotButton) {
                plotButton.addEventListener('click', plotOrbit);
            } else {
                console.error("CRITICAL: Failed to find #plot-button.");
            }
            
            if (toggleButton) {
                toggleButton.addEventListener('click', toggleSidebar);
            } else {
                console.error("Failed to find #toggle-button.");
            }
            
            if (timeScaleSlider && timeScaleValue) {
                timeScaleSlider.addEventListener('input', (e) => {
                    const sliderValue = parseFloat(e.target.value);
                    timeScale = Math.pow(10, sliderValue);
                    timeScaleValue.textContent = `${timeScale.toFixed(0)}x`;
                });
            } else {
                console.error("Failed to find time scale slider or value display.");
            }

            if (clearTrackButton) {
                clearTrackButton.addEventListener('click', clearGroundTrack);
            } else {
                console.error("Failed to find #clear-track-button.");
            }
            
            if (calculateTransferButton) {
                calculateTransferButton.addEventListener('click', calculateHohmannTransfer);
            } else {
                console.error("Failed to find #calculate-transfer-button.");
            }
            
            if (j2Toggle) {
                j2Toggle.addEventListener('change', plotOrbit);
            } else {
                console.error("Failed to find #j2-toggle.");
            }

            animate();
        }
        
        function drawGroundTrackMap() {
            if (!groundTrackCtx || !groundTrackCanvas) return;
            const w = groundTrackCanvas.width;
            const h = groundTrackCanvas.height;
            groundTrackCtx.fillStyle = '#1e293b'; 
            groundTrackCtx.fillRect(0, 0, w, h);
            if (mapImage.complete && mapImage.naturalHeight !== 0) {
                groundTrackCtx.drawImage(mapImage, 0, 0, w, h);
            }
            groundTrackCtx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
            groundTrackCtx.lineWidth = 0.5;
            for (let i = 1; i < 6; i++) {
                const x = (w / 6) * i;
                groundTrackCtx.beginPath();
                groundTrackCtx.moveTo(x, 0);
                groundTrackCtx.lineTo(x, h);
                groundTrackCtx.stroke();
            }
            for (let i = 1; i < 6; i++) {
                const y = (h / 6) * i;
                groundTrackCtx.beginPath();
                groundTrackCtx.moveTo(0, y);
                groundTrackCtx.lineTo(w, y);
                groundTrackCtx.stroke();
            }
        }
        
        function clearGroundTrack() {
            drawGroundTrackMap();
            lastGroundTrackPoint = null; 
        }
        
        function plotGroundTrackPoint(lat_rad, lon_rad) {
            if (!groundTrackCtx || !groundTrackCanvas) return;
            
            const w = groundTrackCanvas.width;
            const h = groundTrackCanvas.height;
            const x = ((lon_rad + Math.PI) / (2 * Math.PI)) * w;
            const y = ((-lat_rad + Math.PI / 2) / Math.PI) * h;
            const point = { x, y, lon: lon_rad };

            if (lastGroundTrackPoint) {
                groundTrackCtx.strokeStyle = '#FFFF00'; 
                groundTrackCtx.lineWidth = 1.5;
                const deltaX = x - lastGroundTrackPoint.x;
                
                if (Math.abs(deltaX) > w / 2) {
                    let x1, y1, x2, y2;
                    if (deltaX > 0) { 
                        x1 = lastGroundTrackPoint.x; y1 = lastGroundTrackPoint.y;
                        x2 = x - w; y2 = y;
                        groundTrackCtx.beginPath();
                        groundTrackCtx.moveTo(x1, y1); groundTrackCtx.lineTo(x2, y2);
                        groundTrackCtx.stroke();
                        x1 = lastGroundTrackPoint.x + w; y1 = lastGroundTrackPoint.y;
                        x2 = x; y2 = y;
                        groundTrackCtx.beginPath();
                        groundTrackCtx.moveTo(x1, y1); groundTrackCtx.lineTo(x2, y2);
                        groundTrackCtx.stroke();
                    } else {
                        x1 = lastGroundTrackPoint.x; y1 = lastGroundTrackPoint.y;
                        x2 = x + w; y2 = y;
                        groundTrackCtx.beginPath();
                        groundTrackCtx.moveTo(x1, y1); groundTrackCtx.lineTo(x2, y2);
                        groundTrackCtx.stroke();
                        x1 = lastGroundTrackPoint.x - w; y1 = lastGroundTrackPoint.y;
                        x2 = x; y2 = y;
                        groundTrackCtx.beginPath();
                        groundTrackCtx.moveTo(x1, y1); groundTrackCtx.lineTo(x2, y2);
                        groundTrackCtx.stroke();
                    }
                } else {
                    groundTrackCtx.beginPath();
                    groundTrackCtx.moveTo(lastGroundTrackPoint.x, lastGroundTrackPoint.y);
                    groundTrackCtx.lineTo(x, y);
                    groundTrackCtx.stroke();
                }
            }
            lastGroundTrackPoint = point;
        }
        
        function clearOrbitObject(group) {
            if (group) {
                const line = group.children[0];
                if (line) {
                    if (line.geometry) line.geometry.dispose();
                    if (line.material) line.material.dispose();
                }
                scene.remove(group);
            }
            return null;
        }
        
        function plotOrbitPath(a_km, e, i_deg, raan_deg, w_deg, color) {
            const points = [];
            const numPoints = 256;
            for (let j = 0; j <= numPoints; j++) {
                const nu = (j / numPoints) * 2 * Math.PI;
                const r = (a_km * (1 - e * e)) / (1 + e * Math.cos(nu));
                const x_prime = r * Math.cos(nu);
                const y_prime = r * Math.sin(nu);
                const p_vec = new THREE.Vector3(x_prime, y_prime, 0);
                points.push(p_vec.clone().multiplyScalar(SCENE_SCALE));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                linewidth: 2,
                transparent: true,
                opacity: 0.8
            });
            const orbitLine = new THREE.Line(geometry, material);

            const orbitGroup = new THREE.Group();
            orbitGroup.rotateZ(raan_deg * Math.PI / 180);
            orbitGroup.rotateX(i_deg * Math.PI / 180);
            orbitGroup.rotateZ(w_deg * Math.PI / 180);
            
            orbitGroup.add(orbitLine);
            return orbitGroup;
        }

        function plotOrbit() {
            if(dataAltitude) dataAltitude.innerHTML = `- <span class="unit">km</span>`; 
            if (dataEclipse) dataEclipse.innerHTML = `-`;
            maneuverErrorText.textContent = "";
            
            currentOrbitGroup = clearOrbitObject(currentOrbitGroup);
            transferOrbitGroup = clearOrbitObject(transferOrbitGroup);
            finalOrbitGroup = clearOrbitObject(finalOrbitGroup);

            if (satellite) satellite.visible = false; 
            currentOrbitParams = null; 
            clearGroundTrack();
            
            dataDv1.innerHTML = `- <span class="unit">m/s</span>`;
            dataDv2.innerHTML = `- <span class="unit">m/s</span>`;
            dataDvTotal.innerHTML = `- <span class="unit">m/s</span>`;
            dataTransferTime.innerHTML = `- <span class="unit">hr</span>`;

            const a_km = parseFloat(document.getElementById('semi-major-axis').value);
            const e = parseFloat(document.getElementById('eccentricity').value);
            const i_deg = parseFloat(document.getElementById('inclination').value);
            const raan_deg = parseFloat(document.getElementById('raan').value);
            const w_deg = parseFloat(document.getElementById('arg-periapsis').value);

            if (isNaN(a_km) || isNaN(e) || isNaN(i_deg) || isNaN(raan_deg) || isNaN(w_deg)) {
                dataAltitude.textContent = "Invalid Input"; 
                return;
            }
            if (e < 0 || e >= 1) {
                dataAltitude.textContent = "e must be 0-1";
                return;
            }
            
            const r_p_km = a_km * (1 - e); 
            const r_a_km = a_km * (1 + e); 
            const alt_p_km = r_p_km - EARTH_RADIUS_KM;
            const alt_a_km = r_a_km - EARTH_RADIUS_KM;
            
            dataRaan.innerHTML = `${raan_deg.toFixed(2)} <span class="unit">°</span>`;
            dataW.innerHTML = `${w_deg.toFixed(2)} <span class="unit">°</span>`;

            if (r_p_km < EARTH_RADIUS_KM) {
                if (dataAltitude) dataAltitude.innerHTML = `<span class="text-red-500 font-bold">CRASH</span>`; 
                dataApoapsis.innerHTML = `${alt_a_km.toFixed(0)} <span class="unit">km</span>`;
                dataPeriapsis.innerHTML = `${alt_p_km.toFixed(0)} <span class="unit">km</span>`;
                dataPeriod.innerHTML = `- <span class="unit">min</span>`;
            } else {
                const T_sec = 2 * Math.PI * Math.sqrt(Math.pow(a_km, 3) / G_KM);
                const T_min = T_sec / 60;
                
                currentOrbitParams = { 
                    a_km, 
                    e, 
                    T_sec, 
                    i_rad: i_deg * Math.PI / 180, 
                    raan_0_rad: raan_deg * Math.PI / 180, 
                    w_0_rad: w_deg * Math.PI / 180,
                    j2Enabled: j2Toggle.checked
                };
                
                dataApoapsis.innerHTML = `${alt_a_km.toFixed(0)} <span class="unit">km</span>`;
                dataPeriapsis.innerHTML = `${alt_p_km.toFixed(0)} <span class="unit">km</span>`;
                dataAltitude.innerHTML = `- <span class="unit">km</span>`; 
                dataPeriod.innerHTML = `${T_min.toFixed(1)} <span class="unit">min</span>`;
                satellite.visible = true; 
                clock.start(); 
                simulationTime = 0; 
                lastGroundTrackPoint = null; 
            }
            
            currentOrbitGroup = plotOrbitPath(a_km, e, i_deg, raan_deg, w_deg, 0x00FFFF);
            scene.add(currentOrbitGroup);
        }
        
        function calculateHohmannTransfer() {
            maneuverErrorText.textContent = "";

            if (!currentOrbitParams) {
                maneuverErrorText.textContent = "Error: Plot an initial orbit first.";
                return;
            }
            if (currentOrbitParams.e > 0.01) {
                maneuverErrorText.textContent = "Error: Initial orbit must be circular (e ≈ 0).";
                return;
            }
            
            const target_alt_km = parseFloat(targetAltitudeInput.value);
            if (isNaN(target_alt_km)) {
                maneuverErrorText.textContent = "Error: Invalid target altitude.";
                return;
            }
            
            transferOrbitGroup = clearOrbitObject(transferOrbitGroup);
            finalOrbitGroup = clearOrbitObject(finalOrbitGroup);

            const r1 = currentOrbitParams.a_km;
            const r2 = target_alt_km + EARTH_RADIUS_KM;
            const i = currentOrbitParams.i_rad * 180 / Math.PI;
            const raan = currentOrbitParams.raan_0_rad * 180 / Math.PI;
            const w = currentOrbitParams.w_0_rad * 180 / Math.PI;
            
            if (r1 === r2) {
                maneuverErrorText.textContent = "Error: Target is the same as initial orbit.";
                return;
            }

            const v1_circ = Math.sqrt(G_KM / r1);
            
            const a_tx = (r1 + r2) / 2;
            
            const v_tx_p = Math.sqrt(G_KM * ((2 / r1) - (1 / a_tx)));
            const v_tx_a = Math.sqrt(G_KM * ((2 / r2) - (1 / a_tx)));
            
            const v2_circ = Math.sqrt(G_KM / r2);
            
            const dv1 = Math.abs(v_tx_p - v1_circ);
            const dv2 = Math.abs(v2_circ - v_tx_a);
            const dv_total = dv1 + dv2;
            
            const T_tx_sec = Math.PI * Math.sqrt(Math.pow(a_tx, 3) / G_KM);
            const T_tx_hr = T_tx_sec / 3600;

            dataDv1.innerHTML = `${(dv1 * 1000).toFixed(1)} <span class="unit">m/s</span>`;
            dataDv2.innerHTML = `${(dv2 * 1000).toFixed(1)} <span class="unit">m/s</span>`;
            dataDvTotal.innerHTML = `${(dv_total * 1000).toFixed(1)} <span class="unit">m/s</span>`;
            dataTransferTime.innerHTML = `${T_tx_hr.toFixed(2)} <span class="unit">hr</span>`;
            
            const e_tx = (r2 - r1) / (r1 + r2);
            let w_tx = w;
            if (e_tx < 0) {
                w_tx = w + 180;
            }
            transferOrbitGroup = plotOrbitPath(a_tx, Math.abs(e_tx), i, raan, w_tx, 0xFF00FF);
            scene.add(transferOrbitGroup);
            
            finalOrbitGroup = plotOrbitPath(r2, 0, i, raan, w, 0x00FF00);
            scene.add(finalOrbitGroup);
        }

        function solveKepler(M, e) {
            let E = (e < 0.8) ? M : Math.PI; 
            let delta = 1;
            const maxIter = 100;
            const tolerance = 1e-8;
            for (let i = 0; i < maxIter && Math.abs(delta) > tolerance; i++) {
                const f = E - e * Math.sin(E) - M;
                const f_prime = 1 - e * Math.cos(E);
                delta = f / f_prime;
                if (Math.abs(delta) > 0.5) {
                    delta = Math.sign(delta) * 0.5;
                }
                E = E - delta;
            }
            return E;
        }

        function animate() {
            requestAnimationFrame(animate);

            if (controls) controls.update();
            
            const delta = clock.getDelta();
            simulationTime += delta * timeScale;
            
            if (earthGroup) {
                earthGroup.rotation.z = (simulationTime * EARTH_ROTATION_RAD_PER_SEC);
            }
            if (cloudMesh) {
                cloudMesh.rotation.z = (simulationTime * EARTH_ROTATION_RAD_PER_SEC * 0.9);
            }

            if (satellite && satellite.visible && currentOrbitParams) {
                try {
                    const { a_km, e, T_sec, i_rad, raan_0_rad, w_0_rad, j2Enabled } = currentOrbitParams;
                    
                    let current_raan_rad = raan_0_rad;
                    let current_w_rad = w_0_rad;

                    if (j2Enabled) {
                        const n_rad_per_sec = (2 * Math.PI) / T_sec;
                        const p_km = a_km * (1 - e * e);
                        const K = -1.5 * J2 * n_rad_per_sec * Math.pow(EARTH_RADIUS_KM / p_km, 2);
                        
                        const cos_i = Math.cos(i_rad);
                        const sin_i_sq = Math.sin(i_rad) * Math.sin(i_rad);
                        
                        const raan_dot_rad_per_sec = K * cos_i;
                        const w_dot_rad_per_sec = K * (2.5 * sin_i_sq - 2);

                        current_raan_rad = (raan_0_rad + raan_dot_rad_per_sec * simulationTime) % (2 * Math.PI);
                        current_w_rad = (w_0_rad + w_dot_rad_per_sec * simulationTime) % (2 * Math.PI);
                        
                        dataRaan.innerHTML = `${(current_raan_rad * 180 / Math.PI).toFixed(2)} <span class="unit">°</span>`;
                        dataW.innerHTML = `${(current_w_rad * 180 / Math.PI).toFixed(2)} <span class="unit">°</span>`;
                    } else {
                        dataRaan.innerHTML = `${(raan_0_rad * 180 / Math.PI).toFixed(2)} <span class="unit">°</span>`;
                        dataW.innerHTML = `${(w_0_rad * 180 / Math.PI).toFixed(2)} <span class="unit">°</span>`;
                    }
                    
                    const n = (2 * Math.PI) / T_sec;
                    const M = (n * simulationTime) % (2 * Math.PI); 

                    const E = solveKepler(M, e);

                    const cos_E = Math.cos(E);
                    const sin_E = Math.sin(E);
                    const cos_nu = (cos_E - e) / (1 - e * cos_E);
                    const sin_nu = (Math.sqrt(1 - e * e) * sin_E) / (1 - e * cos_E);
                    const nu = Math.atan2(sin_nu, cos_nu);
                    const r_km = a_km * (1 - e * e) / (1 + e * Math.cos(nu));
                    
                    const alt_km = r_km - EARTH_RADIUS_KM;
                    if (dataAltitude) {
                        dataAltitude.innerHTML = `${alt_km.toFixed(0)} <span class="unit">km</span>`;
                    }

                    const x_prime = r_km * Math.cos(nu);
                    const y_prime = r_km * Math.sin(nu);

                    const pos_vec_eci = new THREE.Vector3(x_prime, y_prime, 0);
                    const rot_w = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), current_w_rad);
                    const rot_i = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), i_rad);
                    const rot_raan = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), current_raan_rad);
                    
                    pos_vec_eci.applyQuaternion(rot_w);
                    pos_vec_eci.applyQuaternion(rot_i);
                    pos_vec_eci.applyQuaternion(rot_raan);
                    
                    satellite.position.copy(pos_vec_eci.clone().multiplyScalar(SCENE_SCALE));
                    satellite.lookAt(earth.position);
                    satellite.rotateX(Math.PI / 2);
                    
                    const earthRotationAngle = (simulationTime * EARTH_ROTATION_RAD_PER_SEC) % (2 * Math.PI);
                    const pos_vec_ecef = pos_vec_eci.clone().applyAxisAngle(new THREE.Vector3(0, 0, 1), -earthRotationAngle);
                    const r = pos_vec_ecef.length();
                    const latitude_rad = Math.asin(pos_vec_ecef.z / r); 
                    const longitude_rad = Math.atan2(pos_vec_ecef.y, pos_vec_ecef.x); 
                    plotGroundTrackPoint(latitude_rad, longitude_rad);
                    
                    if (dataEclipse) {
                        const satPosKm = pos_vec_eci; 
                        
                        if (satPosKm.x < 0) {
                            const perpDist = Math.sqrt(satPosKm.y * satPosKm.y + satPosKm.z * satPosKm.z);
                            if (perpDist < EARTH_RADIUS_KM) {
                                dataEclipse.innerHTML = `<span class="text-blue-300">In Shadow</span>`;
                            } else {
                                dataEclipse.innerHTML = `<span class="text-yellow-400">In Sunlight</span>`;
                            }
                        } else {
                             dataEclipse.innerHTML = `<span class="text-yellow-400">In Sunlight</span>`;
                        }
                    }

                } catch (e) {
                    console.error("Error during animation:", e);
                    currentOrbitParams = null;
                }
            }

            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function getWidth() {
            return sceneContainer ? sceneContainer.clientWidth : window.innerWidth;
        }
        function getHeight() {
            return sceneContainer ? sceneContainer.clientHeight : window.innerWidth;
        }
        function getAspectRatio() {
            return getWidth() / getHeight();
        }

        function onWindowResize() {
            if (camera && renderer) { 
                camera.aspect = getAspectRatio();
                camera.updateProjectionMatrix();
                renderer.setSize(getWidth(), getHeight());
            }
        }
        
        function toggleSidebar() {
            if (uiContainer) {
                uiContainer.classList.toggle('open');
            } else {
                console.error("Failed to find #ui-container for toggle.");
            }

        }

        try {
            init();
        } catch (e) {
            console.error("CRITICAL ERROR during init():", e);
            const alt = document.getElementById('data-altitude');
            if (alt) {
                alt.textContent = "ERROR! Check console.";
            }
        }
        
    </script>
</body>
</html>

